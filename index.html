<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ADAPTARS</title>
    <style>
        :root {
            --bg: #050505;
            --surface: #111111;
            --primary: #e5e5e5;
            --dim: #444444;
            --accent: #333333;
            --harmonics-active: #b19cd9;
            --slide-color: #002080;
            /* New Colors for Tonality */
            --oto-color: #ffffff; /* White for Otonality */
            --uto-color: #4a90e2; /* Blue for Utonality */
        }
        body {
            margin: 0; background-color: var(--bg); color: var(--primary);
            font-family: 'Courier New', Courier, monospace; overflow: hidden;
            user-select: none; display: flex; flex-direction: column;
            height: 100dvh; overscroll-behavior: none;
        }
        
        /* HEADER */
        header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 20px; border-bottom: 1px solid var(--accent);
            z-index: 10; background: var(--bg); height: 60px; box-sizing: border-box; flex-shrink: 0;
        }

        @keyframes breathe {
            0% { text-shadow: 0 0 5px rgba(255, 255, 255, 0.2); color: #888; opacity: 0.7; }
            50% { text-shadow: 0 0 15px rgba(255, 255, 255, 0.6), 0 0 25px rgba(255, 255, 255, 0.3); color: #fff; opacity: 1; }
            100% { text-shadow: 0 0 5px rgba(255, 255, 255, 0.2); color: #888; opacity: 0.7; }
        }
        .brand { font-weight: bold; letter-spacing: 3px; font-size: 18px; animation: breathe 4s ease-in-out infinite; }
        
        .controls { display: flex; gap: 15px; align-items: center; }
        
        button {
            background: none; border: 1px solid var(--dim); color: var(--dim);
            padding: 8px 12px; cursor: pointer; font-family: inherit; font-size: 14px;
            letter-spacing: 1px; transition: all 0.3s ease; border-radius: 4px; text-align: center;
            min-width: 40px;
        }
        button.active {
            border-color: var(--primary); color: var(--bg); background: var(--primary);
            font-weight: bold; box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        
        #btn-harm { font-size: 12px; border-color: #555; color: #777; width: 40px; }
        #btn-harm.active {
            background: transparent; border-color: var(--harmonics-active); 
            color: var(--harmonics-active); box-shadow: 0 0 8px var(--harmonics-active);
        }

        /* --- TONALITY BUTTON STYLES --- */
        #btn-tonality {
            display: none; /* Hidden by default */
            font-size: 12px; width: 100px;
            border: 1px solid transparent; /* Prepare for glow */
        }
        
        /* Otonality State (White) */
        #btn-tonality.oto {
            color: var(--oto-color);
            border-color: rgba(255, 255, 255, 0.3);
            animation: breathe-oto 3s infinite ease-in-out;
        }
        
        /* Utonality State (Blue) */
        #btn-tonality.uto {
            color: var(--uto-color);
            border-color: rgba(74, 144, 226, 0.3);
            animation: breathe-uto 3s infinite ease-in-out;
        }

        @keyframes breathe-oto {
            0% { box-shadow: 0 0 2px rgba(255, 255, 255, 0.1); text-shadow: 0 0 2px rgba(255,255,255,0.2); opacity: 0.8; }
            50% { box-shadow: 0 0 15px rgba(255, 255, 255, 0.4); text-shadow: 0 0 8px rgba(255,255,255,0.6); opacity: 1; }
            100% { box-shadow: 0 0 2px rgba(255, 255, 255, 0.1); text-shadow: 0 0 2px rgba(255,255,255,0.2); opacity: 0.8; }
        }

        @keyframes breathe-uto {
            0% { box-shadow: 0 0 2px rgba(74, 144, 226, 0.1); text-shadow: 0 0 2px rgba(74, 144, 226,0.2); opacity: 0.8; }
            50% { box-shadow: 0 0 15px rgba(74, 144, 226, 0.4); text-shadow: 0 0 8px rgba(74, 144, 226,0.6); opacity: 1; }
            100% { box-shadow: 0 0 2px rgba(74, 144, 226, 0.1); text-shadow: 0 0 2px rgba(74, 144, 226,0.2); opacity: 0.8; }
        }


        #instrument-container {
            flex-grow: 1; position: relative; cursor: crosshair; touch-action: none;
            width: 100%; height: 100%; overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; }

        #ratio-display {
            font-size: 15vw; font-weight: bold; color: rgba(255,255,255,0.03); 
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            pointer-events: none; z-index: 0; transition: color 0.1s; white-space: nowrap;
        }
        #ratio-display.locked { color: rgba(180, 180, 180, 0.15); }
        
        #start-overlay {
            position: fixed; 
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5,5,5,0.98);
            display: flex; justify-content: center; align-items: center;
            z-index: 9999;
        }
        
        .big-btn {
            border: 1px solid white; 
            padding: 15px 30px; 
            font-size: 20px;
            letter-spacing: 5px; 
            color: white; 
            background: transparent;
            transition: 0.3s;
            margin: 0;
            width: auto; 
            min-width: 200px; 
            display: inline-block; 
            cursor: pointer;
        }
        .big-btn:hover { 
            background: white; 
            color: black; 
            box-shadow: 0 0 20px rgba(255,255,255,0.4); 
        }
    </style>
</head>
<body>

    <div id="start-overlay">
        <button class="big-btn" id="init-btn">INITIALIZE</button>
    </div>

    <header>
        <div class="brand">ADAPTARS</div>
        <div class="controls">
            <button id="btn-vector" class="active">I</button>
            <button id="btn-slate">II</button>
            <button id="btn-tonality">OTONALITY</button> 
            <button id="btn-harm">H</button>
        </div>
    </header>

    <div id="instrument-container">
        <div id="ratio-display"></div>
        <canvas id="canvas"></canvas>
    </div>

    <script>
        // --- 1. CONFIGURATION ---
        const SNAP_THRESHOLD_MAIN = 30; 
        const SNAP_THRESHOLD_SUB = 10;
        const SELECT_ZONE_RATIO = 0.20; 

        // --- 2. GLOBAL VARIABLES ---
        let audioCtx;
        let masterGain;
        let canvas, ctx;
        let width, height;
        
        let isMouseDown = false;
        let currentMode = 'VECTOR';
        let isHarmonicsMode = false;
        let pulses = []; 
        let rawMouseY = 0; 
        let lastMouseY = 0;
        let lastTriggeredStringIndex = -1;
        
        let activeVoices = [];
        let activeTouches = new Map(); 
        let bowedVoices = new Map();

        let slideState = {
            active: false, 
            yLeft: 0, 
            yRight: 0, 
            yCenter: 0,
            displayRatio: 1.0, 
            isSnapped: false,
            controllingTouchId: null,
            isFlat: true
        };

        const scaleMap = [
            { r: 1/1, label: '1/1', main: true }, { r: 81/80 }, { r: 33/32 }, { r: 21/20 }, { r: 16/15 }, { r: 12/11 }, 
            { r: 11/10 }, { r: 10/9 }, { r: 9/8, label: '9/8', main: true }, { r: 8/7 }, { r: 7/6 }, { r: 32/27 }, 
            { r: 6/5, label: '6/5', main: true }, { r: 11/9 }, { r: 5/4, label: '5/4', main: true }, { r: 14/11 }, 
            { r: 9/7 }, { r: 21/16 }, { r: 4/3, label: '4/3', main: true }, { r: 27/20 }, { r: 11/8 }, { r: 7/5 }, 
            { r: 10/7 }, { r: 16/11 }, { r: 40/27 }, { r: 3/2, label: '3/2', main: true }, { r: 32/21 }, { r: 14/9 }, 
            { r: 11/7 }, { r: 8/5, label: '8/5', main: true }, { r: 18/11 }, { r: 5/3 }, { r: 27/16 }, { r: 12/7 }, 
            { r: 7/4 }, { r: 16/9 }, { r: 9/5 }, { r: 20/11 }, { r: 11/6 }, { r: 15/8, label: '15/8', main: true }, 
            { r: 40/21 }, { r: 64/33 }, { r: 160/81 }, { r: 2/1, label: '2/1', main: true }
        ];

        // --- TUNING (STRICTLY FROM DOCS) ---
        
        // GUITAR I: Adapted Guitar I (1934/1945)
        // Tuning: Paired Octaves (Unisons in some versions, but 1945 PDF implies octaves G-g etc.)
        // Base Frequencies: 
        // G = 98 Hz (Low G)
        // Course 1 (Low): Eb = 5/4 below G = 98 * (4/5) = 78.4 Hz
        // Course 2 (Mid): G = 98 Hz
        // Course 3 (High): B = 5/4 above G = 98 * (5/4) = 122.5 Hz
        const vectorCourses = [
            { note: 'Eb', freq: 98 * 0.8 }, 
            { note: 'G',  freq: 98 }, 
            { note: 'B',  freq: 98 * 1.25 }
        ];
        
        // GUITAR II CONFIG
        const slateBase = 49.0; // G1 (Fundamental)
        let slateStrings = [];  

        // Otonality Ratios (From Table 1 in PDF)
        const OTONALITY_RATIOS = [4/3, 16/9, 4/3, 16/9, 10/9, 4/3, 14/9, 16/9, 15/8, 2/1];
        
        // Utonality Ratios (From Table 1 in PDF)
        const UTONALITY_RATIOS = [4/3, 16/9, 4/3, 16/15, 6/5, 4/3, 32/21, 16/9, 15/8, 64/33];

        let currentTonalityMode = 'OTONALITY'; 

        // --- 3. INITIALIZATION ---
        window.onload = () => {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            document.getElementById('init-btn').addEventListener('click', initAudio);
            document.getElementById('btn-vector').addEventListener('click', () => switchMode('VECTOR'));
            document.getElementById('btn-slate').addEventListener('click', () => switchMode('SLATE'));
            document.getElementById('btn-harm').addEventListener('click', toggleHarmonics);
            document.getElementById('btn-tonality').addEventListener('click', toggleTonality);
            
            window.addEventListener('resize', resize);
            
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd, {passive: false});
            canvas.addEventListener('touchcancel', handleTouchEnd, {passive: false});
            
            canvas.addEventListener('mousedown', handleMouseDown);
            window.addEventListener('mousemove', handleMouseMove); 
            window.addEventListener('mouseup', handleMouseUp);

            setTonality('OTONALITY'); 
            resize();
        };

        function resize() {
            if (!canvas) return;
            const container = document.getElementById('instrument-container');
            width = canvas.width = container.clientWidth;
            height = canvas.height = container.clientHeight;
        }

        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.8; 
            masterGain.connect(audioCtx.destination);
            document.getElementById('start-overlay').style.display = 'none';
            if (audioCtx.state === 'suspended') audioCtx.resume();
            requestAnimationFrame(animate);
        }

        function switchMode(mode) {
            currentMode = mode;
            document.getElementById('btn-vector').className = mode === 'VECTOR' ? 'active' : '';
            document.getElementById('btn-slate').className = mode === 'SLATE' ? 'active' : '';
            
            const tonalityBtn = document.getElementById('btn-tonality');
            if (mode === 'SLATE') {
                tonalityBtn.style.display = 'block';
            } else {
                tonalityBtn.style.display = 'none';
            }

            isHarmonicsMode = false;
            document.getElementById('btn-harm').classList.remove('active');
            
            pulses = [];
            activeVoices = []; 
            activeTouches.clear();
            bowedVoices.forEach(v => v.kill()); bowedVoices.clear();
            slideState.active = false;
            slideState.yLeft = 0; slideState.yRight = 0; slideState.isFlat = true;
        }

        function toggleHarmonics() {
            isHarmonicsMode = !isHarmonicsMode;
            const btn = document.getElementById('btn-harm');
            if (isHarmonicsMode) btn.classList.add('active');
            else {
                btn.classList.remove('active');
                bowedVoices.forEach(v => v.kill()); bowedVoices.clear();
            }
            updateSlideState(); 
        }

        function toggleTonality() {
            const newMode = currentTonalityMode === 'OTONALITY' ? 'UTONALITY' : 'OTONALITY';
            setTonality(newMode);
        }

        function setTonality(mode) {
            currentTonalityMode = mode;
            const btn = document.getElementById('btn-tonality');
            btn.innerText = mode;
            
            // Remove old class and add new specific class
            btn.classList.remove('oto', 'uto');
            if (mode === 'OTONALITY') {
                btn.classList.add('oto');
            } else {
                btn.classList.add('uto');
            }
            
            slateStrings = [];
            const ratios = mode === 'OTONALITY' ? OTONALITY_RATIOS : UTONALITY_RATIOS;
            ratios.forEach(r => slateStrings.push(slateBase * r));
            
            updateVoicesPitch();
        }

        // --- 4. DSP UTILITIES ---
        function clamp(x, a, b){ return Math.min(b, Math.max(a, x)); }
        function centsToRatio(c){ return Math.pow(2, c/1200); }
        function makePickNoiseBuffer(ctx, seconds=0.065){
            const n = Math.max(32, Math.floor(ctx.sampleRate * seconds));
            const buf = ctx.createBuffer(1, n, ctx.sampleRate);
            const d = buf.getChannelData(0);
            for (let i=0;i<n;i++){ d[i] = (Math.random()*2 - 1) * Math.pow(1 - i/(n-1), 2.2); }
            return buf;
        }

        // --- 5. SOUND ENGINES ---
        
        // GUITAR I (Classic Warm with OCTAVE DOUBLING)
        // Strictly follows PDF description of paired courses tuned in Octaves (2/1)
        function pluckDoubleCourse(ctx, destination, baseFreq, startRatio, stringX, opt={}){
            const { dur = 2.5, amp = 0.22, bright = 0.65, noise = 0.12, delay2 = 0.012, detune2_cents = 2.5 } = opt;
            const t0 = ctx.currentTime;
            const f1 = baseFreq * startRatio;
            
            // Common body resonance filter
            const body1 = ctx.createBiquadFilter(); body1.type = "peaking"; body1.frequency.value = clamp(220 + f1*0.22, 160, 900); body1.Q.value = 1.2; body1.gain.value = 3.8;
            const body2 = ctx.createBiquadFilter(); body2.type = "peaking"; body2.frequency.value = clamp(520 + f1*0.35, 260, 1800); body2.Q.value = 1.3; body2.gain.value = 2.4;
            const lp = ctx.createBiquadFilter(); lp.type = "lowpass"; lp.frequency.value = clamp(2500 + 12000*bright, 2000, 14000); lp.Q.value = 0.2;
            const out = ctx.createGain(); out.gain.value = 1.0;
            out.connect(body1); body1.connect(body2); body2.connect(lp); lp.connect(destination);
            
            const pickBuf = makePickNoiseBuffer(ctx, 0.065);
            let collectedOscs = [];

            // Helper to create one string
            function oneString(freqMult, startDelay, localAmp, localBright, detuneAmt){
                const ts = t0 + startDelay;
                const startF = f1 * freqMult;
                const env = ctx.createGain();
                env.gain.setValueAtTime(0.00001, ts);
                env.gain.linearRampToValueAtTime(localAmp, ts + 0.010);
                env.gain.exponentialRampToValueAtTime(0.0001, ts + 2.0);
                
                // Individual tone color per string
                const tone = ctx.createBiquadFilter(); tone.type = "lowpass"; 
                tone.frequency.value = clamp(700 + startF*(6 + 18*localBright), 700, 16000); 
                tone.Q.value = 0.22;

                const o1 = ctx.createOscillator(); o1.type = "triangle"; o1.frequency.value = startF;
                const o2 = ctx.createOscillator(); o2.type = "sine"; o2.frequency.value = startF*2;
                const o3 = ctx.createOscillator(); o3.type = "sine"; o3.frequency.value = startF*3;
                
                o1.freqMult = 1 * freqMult; o2.freqMult = 2 * freqMult; o3.freqMult = 3 * freqMult;
                o1.detune.value = detuneAmt; o2.detune.value = detuneAmt; o3.detune.value = detuneAmt;
                
                const g1 = ctx.createGain(); g1.gain.value = 1.0;
                const g2 = ctx.createGain(); g2.gain.value = 0.3;
                const g3 = ctx.createGain(); g3.gain.value = 0.16;
                
                const n = ctx.createBufferSource(); n.buffer = pickBuf;
                const nGain = ctx.createGain(); nGain.gain.value = localAmp * (0.35 + 0.9*noise);
                const nBP = ctx.createBiquadFilter(); nBP.type = "bandpass"; nBP.frequency.value = clamp(startF*2.8, 180, 9000); nBP.Q.value = 0.8;

                o1.connect(g1); g1.connect(tone); o2.connect(g2); g2.connect(tone); o3.connect(g3); g3.connect(tone);
                n.connect(nBP); nBP.connect(nGain); nGain.connect(tone);
                tone.connect(env); env.connect(out);

                o1.start(ts); o2.start(ts); o3.start(ts); n.start(ts); n.stop(ts + 0.070);
                const stopAt = ts + 2.1;
                o1.stop(stopAt); o2.stop(stopAt); o3.stop(stopAt);
                collectedOscs.push(o1, o2, o3);
            }

            // String 1: Fundamental
            oneString(1.0, 0.0, amp, bright, 0);
            
            // String 2: Octave Higher (Ratio 2.0) - Strictly follows Partch's pairing
            const detRatio = centsToRatio((Math.random()*2-1) * detune2_cents);
            oneString(2.0 * detRatio, clamp(delay2, 0.0, 0.03), amp * 0.85, bright * 0.9, detune2_cents);

            const voiceObj = { baseFreq: baseFreq, oscList: collectedOscs, stringX: stringX, type: 'G1' };
            activeVoices.push(voiceObj);
            setTimeout(() => { const idx = activeVoices.indexOf(voiceObj); if(idx > -1) activeVoices.splice(idx, 1); }, 2200);
        }

        // GUITAR II DSP
        function pluckGuitarIISlide(ctx, destination, baseFreq, startRatio, stringX, opt={}){
             const { dur = 3.5, amp = 0.25, bright = 0.75 } = opt;
            const t0 = ctx.currentTime;
            const startF = baseFreq * startRatio;
            const tone = ctx.createBiquadFilter(); tone.type = "lowpass"; tone.frequency.value = clamp(700 + startF * 12, 700, 16000); tone.Q.value = 0.2;
            const out = ctx.createGain(); out.gain.value = 1.0;
            tone.connect(out); out.connect(destination);
            const env = ctx.createGain();
            env.gain.setValueAtTime(0.00001, t0);
            env.gain.linearRampToValueAtTime(amp, t0 + 0.02);
            env.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
            const o1 = ctx.createOscillator(); o1.type = "triangle"; o1.freqMult = 1;
            const o2 = ctx.createOscillator(); o2.type = "sine"; o2.freqMult = 2; 
            const o3 = ctx.createOscillator(); o3.type = "sine"; o3.freqMult = 3;
            o1.frequency.value = startF; o2.frequency.value = startF * 2; o3.frequency.value = startF * 3;
            const g1 = ctx.createGain(); g1.gain.value = 1.0;
            const g2 = ctx.createGain(); g2.gain.value = 0.35;
            const g3 = ctx.createGain(); g3.gain.value = 0.2;
            o1.connect(g1); g1.connect(env); o2.connect(g2); g2.connect(env); o3.connect(g3); g3.connect(env);
            env.connect(tone);
            o1.start(t0); o2.start(t0); o3.start(t0);
            const stopTime = t0 + dur + 0.1;
            o1.stop(stopTime); o2.stop(stopTime); o3.stop(stopTime);
            
            const cfg = { count: 10, spacing: width/10 };
            const strIdx = Math.floor(stringX / cfg.spacing);

            const voiceObj = { 
                baseFreq: baseFreq, 
                oscList: [o1, o2, o3], 
                stringX: stringX, 
                strIdx: strIdx,
                type: 'G2' 
            };
            activeVoices.push(voiceObj);
            setTimeout(() => { const idx = activeVoices.indexOf(voiceObj); if(idx > -1) activeVoices.splice(idx, 1); }, (dur + 0.2) * 1000);
        }

        // HARMONICS (GENTLE VERSION)
        function startBowedHarmonic(ctx, destination, baseFreq, startRatio, stringX, strIdx) {
            const t0 = ctx.currentTime;
            const f = baseFreq * startRatio; 
            const o1 = ctx.createOscillator(); o1.type = "sine"; o1.freqMult = 1; 
            const o2 = ctx.createOscillator(); o2.type = "sine"; o2.freqMult = 2; 
            const o3 = ctx.createOscillator(); o3.type = "sine"; o3.freqMult = 3; 
            const o4 = ctx.createOscillator(); o4.type = "sine"; o4.freqMult = 4; 
            
            o1.frequency.value = f; o2.frequency.value = f*2; o3.frequency.value = f*3; o4.frequency.value = f*4;
            
            const g1 = ctx.createGain(); g1.gain.value = 1.0;
            const g2 = ctx.createGain(); g2.gain.value = 0.4;
            const g3 = ctx.createGain(); g3.gain.value = 0.2;
            const g4 = ctx.createGain(); g4.gain.value = 0.1;
            
            const masterGainNode = ctx.createGain(); 
            masterGainNode.gain.value = 0; 

            // Softer Filters
            const bp = ctx.createBiquadFilter();
            bp.type = "bandpass";
            bp.Q.value = 3; 
            bp.frequency.value = f * 2; 

            const lp = ctx.createBiquadFilter();
            lp.type = "lowpass";
            lp.frequency.value = 3500; 
            lp.Q.value = 0.5;

            o1.connect(g1); g1.connect(masterGainNode); 
            o2.connect(g2); g2.connect(masterGainNode);
            o3.connect(g3); g3.connect(masterGainNode); 
            o4.connect(g4); g4.connect(masterGainNode);
            
            masterGainNode.connect(bp);
            bp.connect(lp);
            lp.connect(destination);
            
            o1.start(t0); o2.start(t0); o3.start(t0); o4.start(t0);

            const voiceObj = { 
                baseFreq: baseFreq, oscList: [o1, o2, o3, o4], partialGains: [g1, g2, g3, g4],
                baseGainValues: [1.0, 0.4, 0.2, 0.1], 
                type: 'HARM', gainNode: masterGainNode, stringX: stringX,
                strIdx: strIdx,
                bpNode: bp, 
                kill: function() {
                    const t = ctx.currentTime;
                    this.gainNode.gain.setTargetAtTime(0, t, 0.4); 
                    setTimeout(() => {
                        o1.stop(); o2.stop(); o3.stop(); o4.stop();
                        const idx = activeVoices.indexOf(this);
                        if(idx > -1) activeVoices.splice(idx, 1);
                    }, 500);
                }
            };
            activeVoices.push(voiceObj);
            return voiceObj;
        }


        // --- 6. LOGIC ---
        function getLocalCoords(evt, canvas) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.clientX || (evt.touches && evt.touches[0] ? evt.touches[0].clientX : 0);
            const clientY = evt.clientY || (evt.touches && evt.touches[0] ? evt.touches[0].clientY : 0);
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function playGuitarICourse(baseFreq, currentRatio, stringX) {
            if (!audioCtx) return;
            pluckDoubleCourse(audioCtx, masterGain, baseFreq, currentRatio, stringX);
        }

        function playGuitarIIString(baseFreq, ratio, stringX) {
            if (!audioCtx) return;
            pluckGuitarIISlide(audioCtx, masterGain, baseFreq, ratio, stringX);
        }

        function getHarmonicRatio(stringX) {
            let targetY;
            if (slideState.isFlat) targetY = slideState.yCenter;
            else {
                const t = stringX / width;
                targetY = slideState.yLeft + (slideState.yRight - slideState.yLeft) * t;
            }
            return calculateRatio(targetY).ratio; 
        }

        function updateBowing(velocity) {
            const slideTouchId = slideState.controllingTouchId;
            const isVector = currentMode === 'VECTOR';
            const cfg = isVector ? { count: 3, spacing: width/3 } : { count: 10, spacing: width/10 };
            
            const activeStringIndices = new Set();
            const selectionZoneTop = height * (1 - SELECT_ZONE_RATIO);

            activeTouches.forEach((data, id) => {
                if (data.y > selectionZoneTop) {
                    const idx = Math.floor(data.x / cfg.spacing);
                    if (idx >= 0 && idx < cfg.count) activeStringIndices.add(idx);
                }
            });

            const isGhostMode = (activeStringIndices.size === 0);
            const speed = Math.abs(velocity);
            
            for (let i=0; i<cfg.count; i++) {
                const isActive = isGhostMode || activeStringIndices.has(i);
                let voice = bowedVoices.get(i);
                
                const visualX = (i * cfg.spacing) + (cfg.spacing/2);
                const r = getHarmonicRatio(visualX);

                if (isActive && speed > 0.5) {
                    if (!voice) {
                        const baseFreq = isVector ? vectorCourses[i].freq : slateStrings[i];
                        voice = startBowedHarmonic(audioCtx, masterGain, baseFreq, r, visualX, i);
                        bowedVoices.set(i, voice);
                    }
                    
                    const vol = Math.min(speed * 0.01 + 0.02, 0.5);
                    voice.gainNode.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.6);
                    
                    voice.partialGains.forEach((pg, idx) => {
                        const base = voice.baseGainValues[idx];
                        const jitter = (Math.random() - 0.5) * (base * 0.3); 
                        pg.gain.setTargetAtTime(Math.max(0, base + jitter), audioCtx.currentTime, 0.2);
                    });

                    voice.oscList.forEach(osc => {
                        const detune = (Math.random() - 0.5) * 1.5; 
                        osc.detune.value = detune;
                        osc.frequency.setTargetAtTime(voice.baseFreq * osc.freqMult * r, audioCtx.currentTime, 0.05);
                    });
                    
                    if(voice.bpNode) {
                         voice.bpNode.frequency.setTargetAtTime(voice.baseFreq * r * 2, audioCtx.currentTime, 0.05);
                    }

                    if (Math.random() > 0.85) {
                        pulses.push({ x: visualX, life: 0.6, color: '#b19cd9', w: 2 });
                    }

                } else {
                    if (voice) voice.gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.3);
                }
            }
        }

        function checkTrigger(x, y, touchId) {
            const selectionZoneTop = height * (1 - SELECT_ZONE_RATIO);
            if (isHarmonicsMode && y > selectionZoneTop) return; 
            if (isHarmonicsMode) return; 

            const cfg = (currentMode === 'VECTOR') ? { count: 3, spacing: width/3 } : { count: 10, spacing: width/10 };
            const strIdx = Math.floor(x / cfg.spacing);
            
            let lastIdx = (touchId === -1) ? lastTriggeredStringIndex : (activeTouches.get(touchId)?.lastStr ?? -1);

            if (strIdx >= 0 && strIdx < cfg.count && strIdx !== lastIdx) {
                const visualX = (strIdx * cfg.spacing) + (cfg.spacing / 2);
                
                let targetY;
                if (slideState.isFlat) targetY = slideState.yCenter;
                else {
                    const t = visualX / width;
                    targetY = slideState.yLeft + (slideState.yRight - slideState.yLeft) * t;
                }
                const r = calculateRatio(targetY).ratio; 

                if (currentMode === 'VECTOR') {
                    const baseFreq = vectorCourses[strIdx].freq;
                    playGuitarICourse(baseFreq, r, visualX);
                    pulses.push({ x: visualX - 5, life: 1, color: '#fff', w: 2 });
                    pulses.push({ x: visualX + 5, life: 1, color: '#fff', w: 2 });
                } else {
                    const baseFreq = slateStrings[strIdx];
                    playGuitarIIString(baseFreq, r, visualX); 
                    pulses.push({ x: visualX, life: 1, color: '#aaa', w: 8 });
                }

                if (touchId === -1) lastTriggeredStringIndex = strIdx;
                else if (activeTouches.has(touchId)) activeTouches.get(touchId).lastStr = strIdx;
            }
        }

        // --- 7. SLIDE PHYSICS ---

        function updateSlideState() {
            const touches = Array.from(activeTouches.values());
            const selectionZoneTop = height * (1 - SELECT_ZONE_RATIO);
            
            let validTouches = [];
            if (isHarmonicsMode) {
                validTouches = touches.filter(t => t.y < selectionZoneTop);
            } else {
                validTouches = touches;
            }
            
            if (validTouches.length === 0 && !isMouseDown) {
                 slideState.active = false;
                 return;
            }
            
            slideState.active = true;

            // Force Flat if Harmonics Mode OR Single Input
            if (isHarmonicsMode || (validTouches.length === 0 && isMouseDown) || validTouches.length === 1) {
                slideState.isFlat = true;
                
                let targetY;
                if (validTouches.length > 0) targetY = validTouches[0].y;
                else targetY = rawMouseY;
                
                const res = calculateRatio(targetY);
                slideState.isSnapped = res.isSnapped; 
                const finalY = res.snappedY || targetY;
                
                slideState.yCenter = finalY;
                slideState.yLeft = finalY;
                slideState.yRight = finalY;
                slideState.displayRatio = res.ratio;
                updateRatioDisplay(res);
                
            } else {
                slideState.isFlat = false;
                slideState.isSnapped = false;
                
                validTouches.sort((a, b) => a.x - b.x);
                const t1 = validTouches[0];
                const t2 = validTouches[validTouches.length - 1];
                
                const safeDx = Math.max(t2.x - t1.x, 1); 
                const m = (t2.y - t1.y) / safeDx;
                
                slideState.yLeft = m * (0 - t1.x) + t1.y;
                slideState.yRight = m * (width - t1.x) + t1.y;
                slideState.yCenter = (slideState.yLeft + slideState.yRight) / 2;
                
                updateRatioDisplay({ display: "", isSnapped: false });
            }
            updateVoicesPitch();
        }

        function calculateRatio(py) {
            let closestDist = Infinity;
            let closestIdx = -1;
            scaleMap.forEach((item, index) => {
                const targetY = (index / (scaleMap.length - 1)) * height;
                const dist = Math.abs(py - targetY);
                const threshold = item.main ? SNAP_THRESHOLD_MAIN : SNAP_THRESHOLD_SUB;
                if (dist < threshold && dist < closestDist) { closestDist = dist; closestIdx = index; }
            });

            if (closestIdx !== -1) {
                return { ratio: scaleMap[closestIdx].r, isSnapped: true, idx: closestIdx, snappedY: (closestIdx / (scaleMap.length - 1)) * height, display: scaleMap[closestIdx].label || formatRatio(scaleMap[closestIdx].r) };
            } else {
                const ratioIdxFloat = (py / height) * (scaleMap.length - 1);
                const idxFloor = Math.floor(ratioIdxFloat);
                const r1 = scaleMap[Math.max(0, idxFloor)];
                const r2 = scaleMap[Math.min(scaleMap.length-1, idxFloor+1)];
                const pct = ratioIdxFloat - idxFloor;
                let r = 1.0; if(r1 && r2) r = r1.r + (r2.r - r1.r) * pct;
                return { ratio: r, isSnapped: false, idx: -1, snappedY: py, display: "" };
            }
        }
        
        function updateRatioDisplay(res) {
            const disp = document.getElementById('ratio-display');
            disp.innerText = res.display;
            if (res.isSnapped) disp.classList.add('locked');
            else disp.classList.remove('locked');
        }

        function updateVoicesPitch() {
            if (activeVoices.length === 0) return;
            const t = audioCtx.currentTime;
            
            activeVoices.forEach(voice => {
                if (currentMode === 'SLATE' && voice.type !== 'G1' && typeof voice.strIdx === 'number') {
                     voice.baseFreq = slateStrings[voice.strIdx];
                }

                let currentY;
                if (slideState.isFlat) currentY = slideState.yCenter;
                else {
                    const pct = voice.stringX / width;
                    currentY = slideState.yLeft + (slideState.yRight - slideState.yLeft) * pct;
                }
                
                const ratioInfo = calculateRatio(currentY);
                const currentR = ratioInfo.ratio;
                
                if (voice.type === 'HARM') {
                    if(voice.bpNode) {
                        voice.bpNode.frequency.setTargetAtTime(voice.baseFreq * currentR * 2, t, 0.05);
                    }
                    return; 
                }

                voice.oscList.forEach(osc => {
                    const newFreq = voice.baseFreq * (osc.freqMult || 1) * currentR;
                    osc.frequency.setTargetAtTime(newFreq, t, 0.05);
                });
            });
        }

        // --- 8. HANDLERS ---

        function handleMouseDown(e) {
            isMouseDown = true;
            const pos = getLocalCoords(e, canvas);
            rawMouseY = pos.y;
            updateSlideState();
            checkTrigger(pos.x, pos.y, -1);
        }
        function handleMouseUp() { 
            isMouseDown = false; lastTriggeredStringIndex = -1; updateSlideState(); 
            bowedVoices.forEach(v => v.kill()); bowedVoices.clear(); 
        }
        function handleMouseMove(e) {
            if (!canvas) return;
            const pos = getLocalCoords(e, canvas);
            rawMouseY = pos.y;
            const vy = pos.y - lastMouseY; lastMouseY = pos.y;
            updateSlideState();
            if(isMouseDown) {
                if (isHarmonicsMode) updateBowing(vy);
                else checkTrigger(pos.x, pos.y, -1);
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            let lastId = -1;
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const tx = t.clientX - rect.left;
                const ty = t.clientY - rect.top;
                
                activeTouches.set(t.identifier, { x: tx, y: ty, lastStr: -1, lastY: ty });
                if (!isHarmonicsMode) checkTrigger(tx, ty, t.identifier);
                lastId = t.identifier;
            }
            updateSlideState(lastId);
        }
        function handleTouchMove(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const touchData = activeTouches.get(t.identifier);
                if (touchData) { 
                    const tx = t.clientX - rect.left;
                    const ty = t.clientY - rect.top;
                    
                    const vy = ty - touchData.lastY;
                    touchData.x = tx; touchData.y = ty; touchData.lastY = ty;
                    
                    if (!isHarmonicsMode) checkTrigger(tx, ty, t.identifier);
                    
                    const selectionZoneTop = height * (1 - SELECT_ZONE_RATIO);
                    if (isHarmonicsMode && ty < selectionZoneTop) {
                        updateBowing(vy);
                    }
                }
            }
            updateSlideState();
        }
        function handleTouchEnd(e) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) { activeTouches.delete(e.changedTouches[i].identifier); }
            if (activeTouches.size === 0) { bowedVoices.forEach(v => v.kill()); bowedVoices.clear(); }
            updateSlideState(); 
        }

        function formatRatio(r) { return r ? r.toFixed(2) : ""; }

        // --- 9. RENDERING ---
        function drawGrid() {
            const step = height / (scaleMap.length - 1);
            scaleMap.forEach((item, index) => {
                const y = index * step;
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y);
                if (slideState.isFlat && slideState.isSnapped && Math.abs(y - slideState.yCenter) < 2) {
                    ctx.strokeStyle = 'rgba(180, 180, 180, 0.5)'; ctx.lineWidth = 2;
                } else if (item.main) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)'; ctx.lineWidth = 1;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)'; ctx.font = '12px Courier New'; ctx.textAlign = 'right';
                    ctx.fillText(item.label, width - 5, y - 2);
                } else { ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)'; ctx.lineWidth = 1; }
                ctx.stroke();
            });
        }

        function drawStrings() {
            const cfg = (currentMode === 'VECTOR') ? { count: 3, spacing: width/3 } : { count: 10, spacing: width/10 };
            const selectionZoneTop = height * (1 - SELECT_ZONE_RATIO);

            for (let i = 0; i < cfg.count; i++) {
                const centerX = (i * cfg.spacing) + (cfg.spacing / 2);
                let highlight = false;
                
                activeTouches.forEach(t => {
                    const inZone = isHarmonicsMode ? (t.y > selectionZoneTop) : true;
                    if (inZone && Math.abs(t.x - centerX) < cfg.spacing/2) highlight = true;
                });

                if (highlight) { ctx.fillStyle = 'rgba(255,255,255,0.05)'; ctx.fillRect(i*cfg.spacing, 0, cfg.spacing, height); }
                
                if (currentMode === 'VECTOR') {
                    ctx.beginPath(); ctx.moveTo(centerX - 5, 0); ctx.lineTo(centerX - 5, height); ctx.strokeStyle = '#999'; ctx.lineWidth = 1.5; ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(centerX + 5, 0); ctx.lineTo(centerX + 5, height); ctx.strokeStyle = '#888'; ctx.lineWidth = 1; ctx.stroke();
                } else {
                    ctx.beginPath(); ctx.moveTo(centerX, 0); ctx.lineTo(centerX, height); 
                    if (currentTonalityMode === 'OTONALITY') ctx.strokeStyle = '#444';
                    else ctx.strokeStyle = '#3e4e5e'; 
                    ctx.lineWidth = 2; ctx.stroke();
                }
            }

            if (isHarmonicsMode) {
                ctx.beginPath(); ctx.moveTo(0, selectionZoneTop); ctx.lineTo(width, selectionZoneTop);
                ctx.strokeStyle = '#b19cd9'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
            }
        }

        function drawPulses() {
            for (let i = pulses.length - 1; i >= 0; i--) {
                let p = pulses[i];
                ctx.shadowBlur = 15 * p.life; ctx.shadowColor = p.color; ctx.strokeStyle = `rgba(255, 255, 255, ${p.life})`; ctx.lineWidth = p.w ? p.w : 3;
                ctx.beginPath(); ctx.moveTo(p.x, 0);
                for (let y = 0; y <= height; y += 30) { ctx.lineTo(p.x + (Math.random() - 0.5) * 10 * p.life, y); }
                ctx.lineTo(p.x, height); ctx.stroke();
                ctx.shadowBlur = 0; p.life -= 0.04; if (p.life <= 0) pulses.splice(i, 1);
            }
        }

        function drawSlide() {
            const y1 = slideState.yLeft;
            const y2 = slideState.yRight;
            const barHeight = 20;
            const darkBlue = 'rgba(0, 32, 128, 0.85)'; const lightBlue = 'rgba(30, 60, 180, 0.8)';

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(0, y1 - barHeight/2);
            ctx.lineTo(width, y2 - barHeight/2);
            ctx.lineTo(width, y2 + barHeight/2);
            ctx.lineTo(0, y1 + barHeight/2);
            ctx.closePath();
            ctx.fillStyle = darkBlue; ctx.fill();

            ctx.beginPath(); ctx.moveTo(0, y1); ctx.lineTo(width, y2);
            ctx.strokeStyle = lightBlue; ctx.lineWidth = 3; ctx.stroke();
            
            ctx.fillStyle = isHarmonicsMode ? '#b19cd9' : '#f00'; 
            activeTouches.forEach(t => { 
                const selectionZoneTop = height * (1 - SELECT_ZONE_RATIO);
                if (!isHarmonicsMode || t.y < selectionZoneTop) {
                    ctx.beginPath(); ctx.arc(t.x, t.y, 15, 0, Math.PI*2); ctx.fill(); 
                }
            });
            ctx.restore();
        }

        function animate() {
            if (!ctx) return;
            ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, width, height);
            drawGrid(); drawStrings(); drawPulses(); drawSlide();
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>
